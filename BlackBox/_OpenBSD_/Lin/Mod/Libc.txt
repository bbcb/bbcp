MODULE LinLibc ["libc.so.90"];

	(*
		OpenBSD 6.2
		i386
	*)

	CONST
		NULL* = 0H;
		FALSE* = 0;
		TRUE* = 1;

		CLOCKS_PER_SEC* = 100;

		MAP_FAILED* = -1;

		(* MAP_PRIVATE, MAP_ANON (intFlags) *)
		MAP_SHARED* = {0}; (* share changes *)
		MAP_PRIVATE* = {1}; (* changes are private *)
		MAP_FIXED* = {4}; (* map addr must be exactly as requested *)
		MAP_ANON* = {12}; (* allocated from memory, swap space *)
		MAP_ANONYMOUS* = MAP_ANON; (* alternate POSIX spelling *)
		MAP_FLAGMASK* = {0..2,4..13};
		MAP_INHERIT_SHARE* = {}; (* share with child *)
		MAP_INHERIT_COPY* = {0}; (* copy into child *)
		MAP_INHERIT_NONE* = {1}; (* absent from child *)
		MAP_INHERIT_ZERO* = {0,1}; (* zero in child *)


		(* PROT_READ, PROT_WRITE, PROT_EXEC (intFlags) *)
		PROT_NONE* = {}; (* no permissions *)
		PROT_READ* = {0}; (* pages can be read *)
		PROT_WRITE* = {1}; (* pages can be written *)
		PROT_EXEC* = {2}; (* pages can be executed *)


		(* SIG_UNBLOCK, SIG_SETMASK (int) *)
		SIG_BLOCK* = 1; (* block specified signal set *)
		SIG_UNBLOCK* = 2; (* unblock specified signal set *)
		SIG_SETMASK* = 3; (* set specified signal set *)


		(* FPE_INTDIV, FPE_INTOVF, FPE_FLTDIV, FPE_FLTOVF, FPE_FLTUND, FPE_FLTRES, FPE_FLTINV, FPE_FLTSUB (int) *)
		FPE_INTDIV* = 1; (* integer divide by zero *)
		FPE_INTOVF* = 2; (* integer overflow *)
		FPE_FLTDIV* = 3; (* floating point divide by zero *)
		FPE_FLTOVF* = 4; (* floating point overflow *)
		FPE_FLTUND* = 5; (* floating point underflow *)
		FPE_FLTRES* = 6; (* floating point inexact result *)
		FPE_FLTINV* = 7; (* invalid floating point operation *)
		FPE_FLTSUB* = 8; (* subscript out of range *)


		(* SA_SIGINFO (intFlags) *)
		SA_NOCLDSTOP* = {3}; (* do not generate SIGCHLD on child stop *)
		SA_ONSTACK* = {0}; (* take signal on signal stack *)
		SA_RESTART* = {1}; (* restart system on signal return *)
		SA_RESETHAND* = {2}; (* reset to SIG_DFL when taking signal *)
		SA_NODEFER* = {4}; (* don't mask the signal we're delivering *)
		SA_NOCLDWAIT* = {5}; (* don't create zombies (assign to pid 1) *)
		SA_SIGINFO* = {6}; (* generate siginfo_t *)


		(* SIGINT, SIGILL, SIGFPE, SIGSEGV, SIGKILL, SIGSTOP, SIGWINCH, SIGTHR (int) *)
		SIGHUP* = 1; (* hangup *)
		SIGINT* = 2; (* interrupt *)
		SIGQUIT* = 3; (* quit *)
		SIGILL* = 4; (* illegal instruction (not reset when caught) *)
		SIGTRAP* = 5; (* trace trap (not reset when caught) *)
		SIGABRT* = 6; (* abort() *)
		SIGFPE* = 8; (* floating point exception *)
		SIGKILL* = 9; (* kill (cannot be caught or ignored) *)
		SIGBUS* = 10; (* bus error *)
		SIGSEGV* = 11; (* segmentation violation *)
		SIGSYS* = 12; (* bad argument to system call *)
		SIGPIPE* = 13; (* write on a pipe with no one to read it *)
		SIGALRM* = 14; (* alarm clock *)
		SIGTERM* = 15; (* software termination signal from kill *)
		SIGURG* = 16; (* urgent condition on IO channel *)
		SIGSTOP* = 17; (* sendable stop signal not from tty *)
		SIGTSTP* = 18; (* stop signal from tty *)
		SIGCONT* = 19; (* continue a stopped process *)
		SIGCHLD* = 20; (* to parent on child stop or exit *)
		SIGTTIN* = 21; (* to readers pgrp upon background tty read *)
		SIGTTOU* = 22; (* like TTIN for output if (tp->t_local&LTOSTOP) *)
		SIGXCPU* = 24; (* exceeded CPU time limit *)
		SIGXFSZ* = 25; (* exceeded file size limit *)
		SIGVTALRM* = 26; (* virtual time alarm *)
		SIGPROF* = 27; (* profiling time alarm *)
		SIGUSR1* = 30; (* user defined signal 1 *)
		SIGUSR2* = 31; (* user defined signal 2 *)
		SIGWINCH* = 28; (* window size changes *)
		SIGTHR* = 32; (* thread library AST *)

		_NSIG* = 33;

(*
		PAGE_SIZE* = 4096;
*)
		_SC_ARG_MAX* = 1;
		_SC_CHILD_MAX* = 2;
		_SC_CLK_TCK* = 3;
		_SC_NGROUPS_MAX* = 4;
		_SC_OPEN_MAX* = 5;
		_SC_JOB_CONTROL* = 6;
		_SC_SAVED_IDS* = 7;
		_SC_VERSION* = 8;
		_SC_BC_BASE_MAX* = 9;
		_SC_BC_DIM_MAX* = 10;
		_SC_BC_SCALE_MAX* = 11;
		_SC_BC_STRING_MAX* = 12;
		_SC_COLL_WEIGHTS_MAX* = 13;
		_SC_EXPR_NEST_MAX* = 14;
		_SC_LINE_MAX* = 15;
		_SC_RE_DUP_MAX* = 16;
		_SC_2_VERSION* = 17;
		_SC_2_C_BIND* = 18;
		_SC_2_C_DEV* = 19;
		_SC_2_CHAR_TERM* = 20;
		_SC_2_FORT_DEV* = 21;
		_SC_2_FORT_RUN* = 22;
		_SC_2_LOCALEDEF* = 23;
		_SC_2_SW_DEV* = 24;
		_SC_2_UPE* = 25;
		_SC_STREAM_MAX* = 26;
		_SC_TZNAME_MAX* = 27;
		_SC_PAGESIZE* = 28;
		_SC_PAGE_SIZE* = _SC_PAGESIZE; (* 1170 compatibility *)
		_SC_FSYNC* = 29;
		_SC_XOPEN_SHM* = 30;
		_SC_SEM_NSEMS_MAX* = 31;
		_SC_SEM_VALUE_MAX* = 32;
		_SC_HOST_NAME_MAX* = 33;
		_SC_MONOTONIC_CLOCK* = 34;
		_SC_2_PBS* = 35;
		_SC_2_PBS_ACCOUNTING* = 36;
		_SC_2_PBS_CHECKPOINT* = 37;
		_SC_2_PBS_LOCATE* = 38;
		_SC_2_PBS_MESSAGE* = 39;
		_SC_2_PBS_TRACK* = 40;
		_SC_ADVISORY_INFO* = 41;
		_SC_AIO_LISTIO_MAX* = 42;
		_SC_AIO_MAX* = 43;
		_SC_AIO_PRIO_DELTA_MAX* = 44;
		_SC_ASYNCHRONOUS_IO* = 45;
		_SC_ATEXIT_MAX* = 46;
		_SC_BARRIERS* = 47;
		_SC_CLOCK_SELECTION* = 48;
		_SC_CPUTIME* = 49;
		_SC_DELAYTIMER_MAX* = 50;
		_SC_IOV_MAX* = 51;
		_SC_IPV6* = 52;
		_SC_MAPPED_FILES* = 53;
		_SC_MEMLOCK* = 54;
		_SC_MEMLOCK_RANGE* = 55;
		_SC_MEMORY_PROTECTION* = 56;
		_SC_MESSAGE_PASSING* = 57;
		_SC_MQ_OPEN_MAX* = 58;
		_SC_MQ_PRIO_MAX* = 59;
		_SC_PRIORITIZED_IO* = 60;
		_SC_PRIORITY_SCHEDULING* = 61;
		_SC_RAW_SOCKETS* = 62;
		_SC_READER_WRITER_LOCKS* = 63;
		_SC_REALTIME_SIGNALS* = 64;
		_SC_REGEXP* = 65;
		_SC_RTSIG_MAX* = 66;
		_SC_SEMAPHORES* = 67;
		_SC_SHARED_MEMORY_OBJECTS* = 68;
		_SC_SHELL* = 69;
		_SC_SIGQUEUE_MAX* = 70;
		_SC_SPAWN* = 71;
		_SC_SPIN_LOCKS* = 72;
		_SC_SPORADIC_SERVER* = 73;
		_SC_SS_REPL_MAX* = 74;
		_SC_SYNCHRONIZED_IO* = 75;
		_SC_SYMLOOP_MAX* = 76;
		_SC_THREAD_ATTR_STACKADDR* = 77;
		_SC_THREAD_ATTR_STACKSIZE* = 78;
		_SC_THREAD_CPUTIME* = 79;
		_SC_THREAD_DESTRUCTOR_ITERATIONS* = 80;
		_SC_THREAD_KEYS_MAX* = 81;
		_SC_THREAD_PRIO_INHERIT* = 82;
		_SC_THREAD_PRIO_PROTECT* = 83;
		_SC_THREAD_PRIORITY_SCHEDULING* = 84;
		_SC_THREAD_PROCESS_SHARED* = 85;
		_SC_THREAD_ROBUST_PRIO_INHERIT* = 86;
		_SC_THREAD_ROBUST_PRIO_PROTECT* = 87;
		_SC_THREAD_SPORADIC_SERVER* = 88;
		_SC_THREAD_STACK_MIN* = 89;
		_SC_THREAD_THREADS_MAX* = 90;
		_SC_THREADS* = 91;
		_SC_TIMEOUTS* = 92;
		_SC_TIMER_MAX* = 93;
		_SC_TIMERS* = 94;
		_SC_TRACE* = 95;
		_SC_TRACE_EVENT_FILTER* = 96;
		_SC_TRACE_EVENT_NAME_MAX* = 97;
		_SC_TRACE_INHERIT* = 98;
		_SC_TRACE_LOG* = 99;
		_SC_GETGR_R_SIZE_MAX* = 100;
		_SC_GETPW_R_SIZE_MAX* = 101;
		_SC_LOGIN_NAME_MAX* = 102;
		_SC_THREAD_SAFE_FUNCTIONS* = 103;
		_SC_TRACE_NAME_MAX* = 104;
		_SC_TRACE_SYS_MAX* = 105;
		_SC_TRACE_USER_EVENT_MAX* = 106;
		_SC_TTY_NAME_MAX* = 107;
		_SC_TYPED_MEMORY_OBJECTS* = 108;
		_SC_V6_ILP32_OFF32* = 109;
		_SC_V6_ILP32_OFFBIG* = 110;
		_SC_V6_LP64_OFF64* = 111;
		_SC_V6_LPBIG_OFFBIG* = 112;
		_SC_V7_ILP32_OFF32* = 113;
		_SC_V7_ILP32_OFFBIG* = 114;
		_SC_V7_LP64_OFF64* = 115;
		_SC_V7_LPBIG_OFFBIG* = 116;
		_SC_XOPEN_CRYPT* = 117;
		_SC_XOPEN_ENH_I18N* = 118;
		_SC_XOPEN_LEGACY* = 119;
		_SC_XOPEN_REALTIME* = 120;
		_SC_XOPEN_REALTIME_THREADS* = 121;
		_SC_XOPEN_STREAMS* = 122;
		_SC_XOPEN_UNIX* = 123;
		_SC_XOPEN_UUCP* = 124;
		_SC_XOPEN_VERSION* = 125;
		_SC_PHYS_PAGES* = 500;
		_SC_AVPHYS_PAGES* = 501;
		_SC_NPROCESSORS_CONF* = 502;
		_SC_NPROCESSORS_ONLN* = 503;


		SIGSTKSZ* = 8192 + 32768;

		(* ENOENT, EEXIST, EACCES, ENOMEM, EDQUOT, EMFILE, ENOTDIR (int) *)
		EPERM* = 1; (* Operation not permitted *)
		ENOENT* = 2; (* No such file or directory *)
		ESRCH* = 3; (* No such process *)
		EINTR* = 4; (* Interrupted system call *)
		EIO* = 5; (* Input/output error *)
		ENXIO* = 6; (* Device not configured *)
		E2BIG* = 7; (* Argument list too long *)
		ENOEXEC* = 8; (* Exec format error *)
		EBADF* = 9; (* Bad file descriptor *)
		ECHILD* = 10; (* No child processes *)
		EDEADLK* = 11; (* Resource deadlock avoided *)
		ENOMEM* = 12; (* Cannot allocate memory *)
		EACCES* = 13; (* Permission denied *)
		EFAULT* = 14; (* Bad address *)
		EBUSY* = 16; (* Device busy *)
		EEXIST* = 17; (* File exists *)
		EXDEV* = 18; (* Cross-device link *)
		ENODEV* = 19; (* Operation not supported by device *)
		ENOTDIR* = 20; (* Not a directory *)
		EISDIR* = 21; (* Is a directory *)
		EINVAL* = 22; (* Invalid argument *)
		ENFILE* = 23; (* Too many open files in system *)
		EMFILE* = 24; (* Too many open files *)
		ENOTTY* = 25; (* Inappropriate ioctl for device *)
		ETXTBSY* = 26; (* Text file busy *)
		EFBIG* = 27; (* File too large *)
		ENOSPC* = 28; (* No space left on device *)
		ESPIPE* = 29; (* Illegal seek *)
		EROFS* = 30; (* Read-only file system *)
		EMLINK* = 31; (* Too many links *)
		EPIPE* = 32; (* Broken pipe *)
		EDOM* = 33; (* Numerical argument out of domain *)
		ERANGE* = 34; (* Result too large *)
		EAGAIN* = 35; (* Resource temporarily unavailable *)
		EWOULDBLOCK* = EAGAIN; (* Operation would block *)
		EINPROGRESS* = 36; (* Operation now in progress *)
		EALREADY* = 37; (* Operation already in progress *)
		ENOTSOCK* = 38; (* Socket operation on non-socket *)
		EDESTADDRREQ* = 39; (* Destination address required *)
		EMSGSIZE* = 40; (* Message too long *)
		EPROTOTYPE* = 41; (* Protocol wrong type for socket *)
		ENOPROTOOPT* = 42; (* Protocol not available *)
		EPROTONOSUPPORT* = 43; (* Protocol not supported *)
		EOPNOTSUPP* = 45; (* Operation not supported *)
		EAFNOSUPPORT* = 47; (* Address family not supported by protocol family *)
		EADDRINUSE* = 48; (* Address already in use *)
		EADDRNOTAVAIL* = 49; (* Can't assign requested address *)
		ENETDOWN* = 50; (* Network is down *)
		ENETUNREACH* = 51; (* Network is unreachable *)
		ENETRESET* = 52; (* Network dropped connection on reset *)
		ECONNABORTED* = 53; (* Software caused connection abort *)
		ECONNRESET* = 54; (* Connection reset by peer *)
		ENOBUFS* = 55; (* No buffer space available *)
		EISCONN* = 56; (* Socket is already connected *)
		ENOTCONN* = 57; (* Socket is not connected *)
		ETIMEDOUT* = 60; (* Operation timed out *)
		ECONNREFUSED* = 61; (* Connection refused *)
		ELOOP* = 62; (* Too many levels of symbolic links *)
		ENAMETOOLONG* = 63; (* File name too long *)
		EHOSTUNREACH* = 65; (* No route to host *)
		ENOTEMPTY* = 66; (* Directory not empty *)
		EDQUOT* = 69; (* Disk quota exceeded *)
		ESTALE* = 70; (* Stale NFS file handle *)
		ENOLCK* = 77; (* No locks available *)
		ENOSYS* = 78; (* Function not implemented *)
		EILSEQ* = 84; (* Illegal byte sequence *)
		EOVERFLOW* = 87; (* Value too large to be stored in data type *)
		ECANCELED* = 88; (* Operation canceled *)
		EIDRM* = 89; (* Identifier removed *)
		ENOMSG* = 90; (* No message of desired type *)
		ENOTSUP* = 91; (* Not supported *)
		EBADMSG* = 92; (* Bad message *)
		ENOTRECOVERABLE* = 93; (* State not recoverable *)
		EOWNERDEAD* = 94; (* Previous owner died *)
		EPROTO* = 95; (* Protocol error *)
		ENOTBLK* = 15; (* Block device required *)
		ESOCKTNOSUPPORT* = 44; (* Socket type not supported *)
		EPFNOSUPPORT* = 46; (* Protocol family not supported *)
		ESHUTDOWN* = 58; (* Can't send after socket shutdown *)
		ETOOMANYREFS* = 59; (* Too many references: can't splice *)
		EHOSTDOWN* = 64; (* Host is down *)
		EPROCLIM* = 67; (* Too many processes *)
		EUSERS* = 68; (* Too many users *)
		EREMOTE* = 71; (* Too many levels of remote in path *)
		EBADRPC* = 72; (* RPC struct is bad *)
		ERPCMISMATCH* = 73; (* RPC version wrong *)
		EPROGUNAVAIL* = 74; (* RPC program not available *)
		EPROGMISMATCH* = 75; (* Program version wrong *)
		EPROCUNAVAIL* = 76; (* Bad procedure for program *)
		EFTYPE* = 79; (* Inappropriate file type or format *)
		EAUTH* = 80; (* Authentication error *)
		ENEEDAUTH* = 81; (* Need authenticator *)
		EIPSEC* = 82; (* IPsec processing failure *)
		ENOATTR* = 83; (* Attribute not found *)
		ENOMEDIUM* = 85; (* No medium found *)
		EMEDIUMTYPE* = 86; (* Wrong medium type *)
		ELAST* = 95; (* Must be equal largest errno *)
		ERESTART* = -1; (* restart syscall *)
		EJUSTRETURN* = -2; (* don't modify regs, just return *)


		WAIT_ANY* = -1; (* any process *)
		WAIT_MYPGRP* = 0; (* any process in my process group *)
		WCONTINUED* = {3}; (* report a job control continued process *)
		WNOHANG* = {0}; (* don't hang in wait *)
		WUNTRACED* = {1}; (* tell about stopped, untraced children *)


		NAME_MAX* = 255;

		SEEK_SET* = 0;
		SEEK_CUR* = 1;
		SEEK_END* = 2;

		STDIN_FILENO* = 0;
		STDOUT_FILENO* = 1;
		STDERR_FILENO* = 2;

		P_tmpdir* = "/tmp";

		(* O_RDWR, O_NONBLOCK (intFlags) *)
		O_SHLOCK* = {4}; (* open with shared file lock *)
		O_EXLOCK* = {5}; (* open with exclusive file lock *)
		O_ASYNC* = {6}; (* signal pgrp when data ready *)
		O_NOFOLLOW* = {8}; (* if path is a symlink, don't follow *)
		O_SYNC* = {7}; (* synchronous writes *)
		O_RDONLY* = {}; (* open for reading only *)
		O_WRONLY* = {0}; (* open for writing only *)
		O_RDWR* = {1}; (* open for reading and writing *)
		O_ACCMODE* = {0,1}; (* mask for above modes *)
		O_NONBLOCK* = {2}; (* no delay *)
		O_APPEND* = {3}; (* set append mode *)
		O_CREAT* = {9}; (* create if nonexistent *)
		O_TRUNC* = {10}; (* truncate to zero length *)
		O_EXCL* = {11}; (* error if already exists *)
		O_DSYNC* = O_SYNC; (* synchronous data writes *)
		O_RSYNC* = O_SYNC; (* synchronous reads *)
		O_NOCTTY* = {15}; (* don't assign controlling terminal *)
		O_CLOEXEC* = {16}; (* atomically set FD_CLOEXEC *)
		O_DIRECTORY* = {17}; (* fail if not a directory *)


		CLOCK_REALTIME* = 0;
		CLOCK_PROCESS_CPUTIME_ID* = 2;
		CLOCK_MONOTONIC* = 3;
		CLOCK_THREAD_CPUTIME_ID* = 4;
		CLOCK_UPTIME* = 5;


	TYPE
		StrArray* = POINTER TO ARRAY [untagged] OF PtrSTR;
		PtrSTR* = POINTER TO ARRAY [untagged] OF SHORTCHAR;

		(* PtrVoid, int, long, size_t, ssize_t, off_t, time_t, clock_t, sigjmp_buf *)
		(* mode_t, intFlags, sigset_t (set) *)
		PtrVoid* = INTEGER;
		int* = INTEGER;
		long* = INTEGER;
		ulong* = INTEGER;
		size_t* = INTEGER;
		ssize_t* = INTEGER;
		off_t* = LONGINT;
		clock_t* = LONGINT;
		clockid_t* = INTEGER;
		time_t* = LONGINT;
		mode_t* = SET;
		pid_t* = INTEGER;
		uid_t* = INTEGER;
		gid_t* = INTEGER;
		dev_t* = INTEGER;
		ino_t* = LONGINT;
		nlink_t* = INTEGER;
		blkcnt_t = LONGINT;
		blksize_t = INTEGER;
		int8_t* = SHORTCHAR;
		u_int8_t* = SHORTCHAR;
		int16_t* = SHORTINT;
		u_int16_t* = SHORTINT;
		int32_t* = INTEGER;
		u_int32_t* = INTEGER;
		int64_t* = LONGINT;
		u_int64_t* = LONGINT;
		wchar_t* = INTEGER;
		sigjmp_buf* = ARRAY [untagged] 11 OF INTEGER;
		intFlags* = SET;
		FILE = ARRAY [untagged] 22 OF INTEGER;
		sigset_t* = ARRAY [untagged] 4 OF BYTE;
		PtrSigset_t* = POINTER [untagged] TO sigset_t;


		tm* = POINTER TO tmDesc;
		tmDesc* = RECORD [untagged]
			(* NOTE: check record size *)
			(* tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec, tm_wday [ , tm_gmtoff ] *)
			(* OpenBSD 6.0 /usr/include/time.h *)
				tm_sec*: int; (* seconds after the minute [0-60] *)
				tm_min*: int; (* minutes after the hour [0-59] *)
				tm_hour*: int; (* hours since midnight [0-23] *)
				tm_mday*: int; (* day of the month [1-31] *)
				tm_mon*: int; (* months since January [0-11] *)
				tm_year*: int; (* years since 1900 *)
				tm_wday*: int; (* days since Sunday [0-6] *)
				tm_yday*: int; (* days since January 1 [0-365] *)
				tm_isdst*: int; (* Daylight Saving Time flag *)
				tm_gmtoff*: long; (* offset from UTC in seconds *)
				tm_zone*: PtrSTR; (* timezone abbreviation *)
		END;

		Ptrsiginfo_t* = POINTER TO siginfo_t;
		siginfo_t = RECORD [untagged]
			(* si_code, fault address *)
			(* OpenBSD 5.9 /usr/include/sys/siginfo.h *)
				si_signo*: int; (* signal from signal.h *)
				si_code*: int; (* code from above *)
				si_errno*: int; (* error from errno.h *)
				_data*: RECORD [union]
					_pad*: ARRAY [untagged] 29 (* SI_PAD *) OF int; (* for future growth *)
					_proc*: RECORD [untagged] (* kill(), SIGCLD, siqqueue() *)
						_pid*: pid_t; (* process ID *)
						_pdata*: RECORD [union]
							_kill*: RECORD [untagged]
								_uid*: uid_t;
(*
								_value*: sigval;
*)
								_value*: int
							END;
							_cld*: RECORD [untagged]
								_utime*: clock_t;
								_stime*: clock_t;
								_status*: int;
							END;
						END;
					END;
					_fault*: RECORD [untagged] (* SIGSEGV, SIGBUS, SIGILL and SIGFPE *)
						_addr*: PtrVoid; (* faulting address *)
						_trapno*: int; (* illegal trap number *)
					END;
				END;
		END;

		Ptrucontext_t* = POINTER TO ucontext_t;
		ucontext_t = RECORD [untagged]
			(* IP, SP, FP *)
			(* OpenBSD 5.9 /usr/include/i386/signal.h struct sigcontext *)
				sc_gs*: int;
				sc_fs*: int;
				sc_es*: int;
				sc_ds*: int;
				sc_edi*: int;
				sc_esi*: int;
				sc_ebp*: int;
				sc_ebx*: int;
				sc_edx*: int;
				sc_ecx*: int;
				sc_eax*: int;
				(* XXX *)
				sc_eip*: int;
				sc_cs*: int;
				sc_eflags*: int;
				sc_esp*: int;
				sc_ss*: int;

				__sc_unused: int;
				sc_mask*: int; (* signal mask to restore *)

				sc_trapno*: int; (* XXX should be above *)
				sc_err*: int;

				sc_fpstate*: RECORD [union]
					(* OpenBSD 5.9 /usr/include/i386/npx.h union savefpu *)
(*
						sv_87*: RECORD [untagged]
							...
						END;
						sv_xmm*: RECORD [untagged]
							...
						END;
*)
				END;
		END;

		sigaction_t* = RECORD [untagged]
(*
			sa_sigaction*: PROCEDURE [ccall] (sig: INTEGER; siginfo: Ptrsiginfo_t; context: Ptrucontext_t),
			sa_flags*: intFlags, sa_mask*: sigset_t
*)
			(* OpenBSD 5.9 /usr/include/sys/signal.h *)
				sa_sigaction*: PROCEDURE [ccall] (sig: int; siginfo: Ptrsiginfo_t; ctx: Ptrucontext_t);
				sa_mask*: sigset_t;
				sa_flags*: intFlags;
		END;

		stack_t* = RECORD [untagged]
(*
			ss_sp*: PtrVoid, ss_size*: size_t, ss_flags*: intFlags
*)
			(* OpenBSD 5.9 /usr/include/sys/signal.h *)
				ss_sp*: PtrVoid; (* signal stack base *)
				ss_size*: size_t; (* signal stack length *)
				ss_flags*: intFlags; (* SS_DISABLE and/or SS_ONSTACK *)
		END;

		stat_t* = RECORD [untagged]
(*
			NOTE: check record size
			st_mode*: mode_t, st_size*: off_t, st_mtime*: time_t
*)
			(* OpenBSD 5.9 /usr/include/sys/stat.h *)
				st_mode*: mode_t;
				st_dev*: dev_t;
				st_ino*: ino_t;
				st_nlink*: nlink_t;
				st_uid*: uid_t;
				st_gid*: gid_t;
				st_rdev*: dev_t;

				st_atime*: time_t;
				st_atimensec*: long;
				st_mtime*: time_t;
				st_mtimensec*: long;
				st_ctime*: time_t;
				st_ctimensec*: long;

				st_size*: off_t;
				st_blocks*: blkcnt_t;
				st_blksize*: blksize_t;
				st_flags*: u_int32_t;
				st_gen*: u_int32_t;

				__st_birthtime*: time_t;
				__st_birthtimensec*: long;
		END;

		PtrFILE* = PtrVoid;
		PtrDIR* = PtrVoid;

		PtrDirent* = POINTER TO Dirent;
		Dirent = RECORD [untagged]
(*
			d_name*: ARRAY [untagged] NAME_MAX + 1 OF SHORTCHAR
*)
			(* OpenBSD 5.9 /usr/include/sys/dirent.h *)
				d_fileno*: ino_t; (* file number of entry *)
				d_off*: off_t; (* offset after this entry *)
				d_reclen*: u_int16_t; (* length of this record *)
				d_type*: u_int8_t; (* file type, see below *)
				d_namlen*: u_int8_t; (* length of string in d_name *)
				__d_padding: ARRAY [untagged] 4 OF u_int8_t; (* suppress padding after d_name *)
				d_name*: ARRAY [untagged] 255 + 1 OF SHORTCHAR;
		END;

		timespec_t* = RECORD [untagged]
			(* OpenBSD 5.9 /usr/include/time.h *)
				tv_sec*: time_t; (* seconds *)
				tv_nsec*: long; (* and nanoseconds *)
		END;

(*
	VAR
		stdin*: INTEGER;
		timezone*: INTEGER; (* or tm.tm_gmtoff *)
*)
(*
	PROCEDURE [ccall] __errno_location* (): PtrVoid;
*)
(*
	(* POSIX.1 *)
		PROCEDURE [ccall] stat* (path: PtrSTR; VAR sp: stat_t): int;
*)
(*
	VAR
		(* OpenBSD: stdin, stdout, stderr *)
			__sF*: ARRAY [untagged] 3 OF FILE; (* OpenBSD 5.8 /usr/include/stdio.h *)
				(*
					stdin = SYSTEM.ADR(__sF[0])
					stdout = SYSTEM.ADR(__sF[1])
					stderr = SYSTEM.ADR(__sF[2])
				*)
*)

	PROCEDURE [ccall] __errno_location* ["__errno"] (): PtrVoid;

	(* POSIX.1 *)
		PROCEDURE [ccall] stat* (path: PtrSTR; VAR sp: stat_t): int;

		PROCEDURE [ccall] lseek* (d: int; offset: off_t; whence: int): off_t;

	(* XPG4 *)
		PROCEDURE [ccall] fseeko* (stream: PtrFILE; offset: off_t; whence: int): int;

	(* POSIX.1 *)
		PROCEDURE [ccall] sigsetjmp* (VAR env: sigjmp_buf; savemask: int): int;


	(* ANSI C 89 *)
		PROCEDURE [ccall] clock* (): clock_t;

	(* POSIX.1 *)
		PROCEDURE [ccall] clock_gettime* (clock_id: clockid_t; VAR tp: timespec_t): int;

	PROCEDURE [ccall] mmap* (adr: PtrVoid; len: size_t; prot: intFlags; flags: intFlags; fd: int; offset: off_t): PtrVoid;
	(* BSD *)
		PROCEDURE [ccall] munmap* (adr: PtrVoid; len: size_t): int;
		PROCEDURE [ccall] mprotect* (adr: PtrVoid; len: size_t; prot: intFlags): int;

(*
	PROCEDURE [ccall] calloc* (nmemb: size_t; size: size_t): PtrVoid;
	(* ANSI C 89 *)
		PROCEDURE [ccall] malloc* (size: size_t): PtrVoid;
*)
		PROCEDURE [ccall] free* (ptr: PtrVoid);

	(* AT&T *)
		PROCEDURE [ccall] time* (VAR [nil] t: time_t): time_t;
	PROCEDURE [ccall] gmtime* (VAR [nil] t: time_t): tm;
	PROCEDURE [ccall] localtime* (VAR [nil] t: time_t): tm;

	(* POSIX.1 *)
(*
		PROCEDURE [ccall] sigsetjmp* (VAR env: sigjmp_buf; savemask: int): int;
*)
		PROCEDURE [ccall] siglongjmp* (VAR env: sigjmp_buf; val: int);

	(* POSIX.1 *)
		PROCEDURE [ccall] sigemptyset* (set: PtrSigset_t): int;
		PROCEDURE [ccall] sigfillset* (set: PtrSigset_t): int;
		PROCEDURE [ccall] sigaddset* (set: PtrSigset_t; signo: int): int;
		PROCEDURE [ccall] sigprocmask* (how: int; set: PtrSigset_t; oset: PtrSigset_t): int;

	(* POSIX.1 *)
		PROCEDURE [ccall] sigaction* (sig: int; VAR [nil] act: sigaction_t; VAR [nil] oact: sigaction_t): int;

	(* BSD *)
		PROCEDURE [ccall] sigaltstack* (VAR [nil] ss: stack_t; VAR [nil] oss: stack_t): int;

	(* ANSI C 89 *)
		PROCEDURE [ccall] getenv* (s: PtrSTR): PtrSTR;

	(* ANSI C 89 *)
		PROCEDURE [ccall] fopen* (path, mode: PtrSTR): PtrFILE;
		PROCEDURE [ccall] fdopen* (fildes: int; mode: PtrSTR): PtrFILE;
		PROCEDURE [ccall] fclose* (stream: PtrFILE): int;
		PROCEDURE [ccall] fread* (ptr: PtrVoid; size: size_t; nmemb: size_t; stream: PtrFILE): size_t;
		PROCEDURE [ccall] fwrite* (ptr: PtrVoid; size: size_t; nmemb: size_t; stream: PtrFILE): size_t;
		PROCEDURE [ccall] fflush* (s: PtrFILE): int;
		PROCEDURE [ccall] printf* (s: PtrSTR): int;
	(* ANSI C 89, XPG4 *)
		PROCEDURE [ccall] fseek* (stream: PtrFILE; offset: long; whence: int): int;

	(* POSIX.1 *)
		PROCEDURE [ccall] fileno* (stream: PtrFILE): int;

	(* POSIX.1 *)
		PROCEDURE [ccall] rename* (from, to: PtrSTR): int;
		PROCEDURE [ccall] mkdir* (path: PtrSTR; mode: mode_t): int;
		PROCEDURE [ccall] opendir* (filename: PtrSTR): PtrDIR;
		PROCEDURE [ccall] readdir* (dirp: PtrDIR): PtrDirent;
		PROCEDURE [ccall] closedir* (dirp: PtrDIR): int;
	(* ANSI C 89, XPG4.2 *)
		PROCEDURE [ccall] remove* (path: PtrSTR): int;

	(* POSIX.1 *)
		PROCEDURE [ccall] getcwd* (buf: PtrSTR; size: size_t): PtrSTR;

	(* ANSI C 99 *)
		PROCEDURE [ccall] exit* (status: int);

	(* ANSI C 89 *)
		PROCEDURE [ccall] strftime* (buf: PtrSTR; maxsize: size_t; format: PtrSTR; timeptr: tm): size_t;

	(* XXX: use fread instead *)
		PROCEDURE [ccall] fgets* (str: PtrSTR; size: int; stream: PtrFILE): PtrSTR;

	(* POSIX.1 *)
		PROCEDURE [ccall] open* (path: PtrSTR; flags: intFlags; mode: mode_t): int;
		PROCEDURE [ccall] write* (d: int; buf: PtrVoid; nbytes: size_t): ssize_t;
		PROCEDURE [ccall] read* (d: int; buf: PtrVoid; nbytes: size_t): ssize_t;
		PROCEDURE [ccall] close* (d: int): int;

	(* POSIX.1 *)
		PROCEDURE [ccall] chmod* (path: PtrSTR; mode: mode_t): int;
		PROCEDURE [ccall] fchmod* (fd: int; mode: mode_t): int;

	(* POSIX.1 *)
		PROCEDURE [ccall] fork* (): pid_t;
		PROCEDURE [ccall] waitpid* (wpid: pid_t; VAR [nil] status: int; options: intFlags): pid_t;

	(* POSIX.1 *)
		PROCEDURE [ccall] execv* (path: PtrSTR; argv: POINTER [untagged] TO ARRAY [untagged] OF PtrSTR): int;
		PROCEDURE [ccall] execvp* (file: PtrSTR; argv: POINTER [untagged] TO ARRAY [untagged] OF PtrSTR): int;

	(* POSIX.2 *)
		PROCEDURE [ccall] system* (string: PtrSTR): int;

	(* POSIX.1 *)
		PROCEDURE [ccall] sysconf* (name: int): long;

	PROCEDURE [ccall] popen* (command, type: PtrSTR): PtrFILE;
	PROCEDURE [ccall] pclose* (stream: PtrFILE): int;

END LinLibc.
